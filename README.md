# Image_compression_using_trees
## HEADER
In header.h am declarete structurile pentru nod, matrice, coada, celula unei cozi si mai contine si antetele functiilor din fisierul "functii.c".

## FUNCTII 
- Primele 3 functii sunt pentru determinarea culorii medii pentru pigmentul rosu, verde si albastru conform formulei din cerinta temei, functii ce returneaza un intreg.
- A patra formula calculeaza un mean cu ajutorul culorilor medii calculate cu formulele de mai sus, valoare data de formula din cerinta. Functia returneaza un intreg.
- Functia "construire" returneaza arborele construit dupa urmatorul algoritm: se calculeaza media celor 3 culori, apoi mean, si in functie de mean hotaram daca arborele trebuie divizat sau nu. Daca mean <= factor (primit ca parametru in functie) inseamna ca arborele nu mai trebuie divizat si atribuim informatiile (r g b si tipul nodului) nodului nou alocat si facem legaturile pe null(ceea ce inseamn ca am ajuns la o frunza).
- Daca mean > factor continuam divizarea prin atribuirea valorii maxime pe care o poate avea un pigment fiecarei informatii pe care o contine nodul si ii dam tipul 0. Apelam recursiv astfel incat sa se construiasca 4 fii care sa verifice la randul lor daca trebuie divizati sau nu in functie de parametri primiti. Variabilele x si y indica coltul din stanga sus a matricei pe portinea pe care trebuie calculat mean.
- Functia "parcurge" nu am nevoie de ea in program, dar m-a ajutat pe mine sa vad daca construiesc arborele bine. E o functie de afisare asemanatoare cu RSD
- Functia "NrNiv" returneaza numarul de niveluri. Apelam functia pentru fiecare fiu si la final ii comparam si il returnam pe cel mai mare + 1.
- Functia "niv_min" returneaza nivelul min, apelam pentru fiecare fiu, daca are, si daca nu are returneaza nivelul primit ca parametru. La final in functie este posibil sa ajungem sa comparam 4 valori si sa o returnam pe cea mai mica.
- Functia "nr_blocuri" returneaza numarul de frunze al arborelui. Daca arborele este vid returneaza 0, daca este frunza 1, iar in rest returneaza valoarile adunate la apel pentru cei 4 copii .
- Functia "InitCoada" initializarea coada in mod clasic, aloca memorie si faca legaturile pentru inceput si sfarsit pe null.
- Functia "IntrCoada" aloca memorie pentru o noua celula de coada, atribuie nodului din celula valoarea nodului primit ca parametru, si face legaturile astfel incat noua celula sa fie mereu ultima din coada.
- Functia "DistrCoada" elibereaza memoria alocoata pentru coada, mai intai elibereaza nodul si apoi celula in sine.
- Functia "distruge" elibereaza memoria arborelui incepand de la frunze spre radacina.
- Functia "parc_latime" scrie in fisier mai intai dimensiunea imaginii si introduce in coada radacina arborelui. Apoi parcurgem coada si scriem in fisier tipul fiecarui nod, daca este frunza ii punem si valorile pixelilor, iar daca nu introducem in coada cei 4 descendenti si trecem la urmatoarea celula.
- Functia "decomp_arb" citeste din fisier tipul nodului, valoare pe care o si pun in nodul din celula curenta a cozii. Daca valoarea este 0 aloca memorie pentru 4 noduri si 4 celule de coada, iar pentru fiecare fac urmatorii pasi: ii atribui valoarea arborelui nodului din celula nou alocata, leg celula cu NULL, leg celula la sfarsitul cozii si mut sfarsitul. Daca este 1 atunci citesc din fisier 3 elemente care ar corespunde celor 3 valori ale unui pixel si actualizez celula curenta.
- Functia "const_matrix" primeste ca parametru un arbore, o matrice, dimensiunea unei imagini, si doua coordonate, x si y. Daca tipul nodului este 1 (adica frunza) punem in matricea ce are dimensiunea imaginii, valoarea primita ca parametru, pornind din coltul de coordonate x si y cele 3 valori ale unui pixel, iar daca este 0 atunci micsoram dimensiunea imaginii la jumatate si apelam recursiv functia pentru fiecare copil, insa difera coordonatele de la unul la altul (coornonatele sunt conform cerintei, impartirii unui patrat in alte 4 patrate mai mici si numerotarea lor).

## MAIN
- Cum primele 2 cerinte au la inceput lucruri in comun, am decis sa le separ mai pe final. Am deschis fisierul din care trebuie sa citesc, am citit valorile de inceput din fisier (p6, dimensiune, dimensiune, valoare maxima a unui pixel), apoi am alocat memorie pentru matrice si am pun in ea valorile din fisier. Am alocat memorie pentru un arbore dupa care am apelat functia ce construieste arborele cu valorile din fisier.
- Daca vrem sa rezolvam tema pentru cerinta 1 atunci deschidem un fisier in format text in care introducem numarul de niveluri ale arborelui, nr de blocuri, dar si dimensiunea cea mai mare a unui bloc.
- Pentru cerinta 2 deschidem fisierul in format binar, declaram si initializam o coada, apelam functia de parcurgere pe latime si afisarea nodurilor in fisierul out primit ca paramatru, dupa care distrugem coada si inchidem fisierul. La final distrugem arborele, matricea si inchidem fisierul de intrare.
- La cerinta 3 deschidem cele doua fisiere in format binar, dupa care luam din fisierul de intrare dimensiunea imaginii, declaram si initializam o coada, alocam spatiu pentru un arbore si o celula din coada, legam fii arborelui pe null, dupa care atribuim valoarea arborelui nodului din celula alocara si legam inceputul si sfarsitul cozii. Apelam functia de construire a cozii avand ca parametru fisierul de intrare, coada, dar si celula de inceput a cozii. Alocam memorie pentru o matrice patratica de dimensiunea imaginii  dupa care cu ajutorul functiei const_matrix atribuim matricei valorile corespunzatoare. Scriem in fisierul de iesire valorile de inceput a unui fisier PPM, dupa care valorile din matrice. La final eliberam coada, matricea si inchidem fisierele.
